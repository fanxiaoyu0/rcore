<center><h1>lab2</h1></center>

<center><h6>范逍宇 2019013273</h6></center>

### 实验

src/task/task.rs

TaskControlBlock 中的两个变量 start_time 和 syscall_times 分别用于记录程序开始运行的时间和参数在 syscall 的调用次数中。

src/task/mod.rs

在构造操作 TASK_MANAGER 时加入对 start_time 和 syscall_times 的初始化，否则会报错。

修改run_firsttask和run_next_task的修改时间，如果这是第一次运行任务，就一次任务启动的时间_管理器记录为当前的时间。

src/系统调用/mod.rs

修改 syscall 函数，在进入具体的 syscall 函数之前，根据 syscall_id 修改当前任务的 syscall_times，将对应的 syscall 类型的计数加一。

src/syscall/process.rs

修改 sys_get_time ，先将地址转为用户地址空间的地址，再写入时间。

在 sys_task_info 函数中将当前进程的 TaskInfo 赋给 ti，而 ti 是用户程序就传递的参数的引用，所以先将 ti 转为用户地址空间的地址，再修改 ti ，这样就实现了将信息反馈给用户。

mmap 先判断参数是否非法，再分配地址空间直到大于 len 字节，并实现虚拟地址和物理地址的映射。

munmap 先判断参数是否非法，再销毁地址空间即可。







### 问答题：

1.[63:54]为保留项，[53:10]为44位物理页号，最低的8位[7:0]为标志位。

- V(Valid)：仅当位 V 为 1 时，页表项才是合法的；
- R(Read)/W(Write)/X(eXecute)：分别控制索引到这个页表项的对应虚拟页面是否允许读/写/执行；
- U(User)：控制索引到这个页表项的对应虚拟页面是否在 CPU 处于 U 特权级的情况下是否被允许访问；
- A(Accessed)：处理器记录自从页表项上的这一位被清零之后，页表项的对应虚拟页面是否被访问过；
- D(Dirty)：处理器记录自从页表项上的这一位被清零之后，页表项的对应虚拟页面是否被修改过。

2.

+ mcause 寄存器中会保存发生中断异常的原因，其中`Exception Code`为`12`时发生指令缺页异常，为`15`时发生`store/AMO`缺页异常，为`13`时发生`load`缺页异常。

+ scause: 中断/异常发生时，`CSR`寄存器`scause`中会记录其信息，`Interrupt`位记录是中断还是异常，`Exception Code`记录中断/异常的种类。

  sstatus: 记录处理器当前状态，其中`SPP`段记录当前特权等级。

  stvec: 记录处理`trap`的入口地址，现有两种模式`Direct`和`Vectored`。

  sscratch: 其中的值是指向hart相关的S态上下文的指针，比如内核栈的指针

  sepc: `trap`发生时会将当前指令的下一条指令地址写入其中，用于`trap`处理完成后返回。

  stval: trap 发生进入S态时会将异常信息写入，用于帮助处理 trap，其中会保存导致缺页异常的虚拟地址

+ Lazy策略一定不会比直接加载策略慢，并且可能会提升性能，因为可能会有些页面被加载后并没有进行访问就被释放或替代了，这样可以避免很多无用的加载。
+ 大致占用`10G/512=20M`内存。
+ 分配内存时暂时不进行分配，只是将记录下来，访问缺页时会触发缺页异常，在`trap handler`中处理相应的异常，在此时将内存加载或分配即可。
+ 页面失效会将标志位`V`置为`0`。将置换出的物理页面保存在磁盘中，在之后访问再次触发缺页异常时将该页面写入内存。

3.

+ 
+ 将内核页面的 pte 的`U`标志位设置为0。
+ 在内核和用户态之间转换时不需要更换页表，也就不需要跳板，可以像之前一样直接切换上下文。
+ 双页表实现下用户程序和内核转换时、用户程序转换时都需要更换页表，而对于单页表操作系统，不同用户线程切换时需要更换页表。